import axios, { AxiosError } from 'axios';
import { encode } from 'gpt-tokenizer';
import { HARData, GenerationOptions, GeneratedTest } from '@/types';
import { LLMProvider } from '../LLMService';
import { AuthFlow, AuthFlowAnalyzer } from '../../AuthFlowAnalyzer';
import { normalizePath } from '../../EndpointGrouper';
import { PromptBuilder } from '../PromptBuilder';
import { Logger } from '../../logging/Logger';

interface GeminiErrorResponse {
  error?: {
    message: string;
    status: string;
    code: number;
  };
}

export class GeminiProvider implements LLMProvider {
  private apiKey: string = '';
  private baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
  private maxRetries = 2;
  private retryDelay = 1000;

  setApiKey(key: string): void {
    this.apiKey = key;
  }

  async generateTests(
    harData: HARData,
    options: GenerationOptions,
    authFlow?: AuthFlow,
    customAuthGuide?: string,
    signal?: AbortSignal
  ): Promise<GeneratedTest> {
    if (!this.apiKey) {
      throw new Error('Gemini API key not configured');
    }

    const prompt = this.buildExhaustivePrompt(harData, options, authFlow, customAuthGuide);
    const promptTokens = this.countTokens(prompt);

    // Check token limits - leave room for complete responses
    const modelLimit = this.getMaxTokens(options.model);
    if (promptTokens > modelLimit * 0.4) { // Leave 60% for response
      throw new Error(`Prompt too large for ${options.model}. Consider reducing the number of requests.`);
    }

    let lastError: Error | null = null;
    
    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        const modelName = this.getModelName(options.model);
        const response = await axios.post(
          `${this.baseUrl}/models/${modelName}:generateContent?key=${this.apiKey}`,
          {
            contents: [
              {
                parts: [
                  {
                    text: `You are an expert API test engineer. Generate clean, production-ready test code.\n\n${prompt}`,
                  },
                ],
              },
            ],
            generationConfig: {
              temperature: 0.7,
              topK: 40,
              topP: 0.95,
              maxOutputTokens: Math.min(65536, Math.floor((modelLimit - promptTokens) * 0.95)), // Use up to 95% of remaining tokens
            },
            safetySettings: [
              {
                category: 'HARM_CATEGORY_HARASSMENT',
                threshold: 'BLOCK_NONE',
              },
              {
                category: 'HARM_CATEGORY_HATE_SPEECH',
                threshold: 'BLOCK_NONE',
              },
              {
                category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
                threshold: 'BLOCK_NONE',
              },
              {
                category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
                threshold: 'BLOCK_NONE',
              },
            ],
          },
          {
            headers: {
              'Content-Type': 'application/json',
            },
            timeout: 120000,
            signal
          }
        );

        // Extract generated text from Gemini response
        const rawCode = this.extractGeneratedText(response.data);
        if (!rawCode) {
          throw new Error('No content generated by Gemini');
        }

        const generatedCode = PromptBuilder.getInstance().sanitizeGeneratedCode(rawCode, options.framework);
        const completionTokens = this.countTokens(generatedCode);
        const totalTokens = promptTokens + completionTokens;
        const qualityScore = this.calculateQualityScore(generatedCode, harData);

        return {
          id: `test_${Date.now()}`,
          framework: options.framework,
          code: generatedCode,
          qualityScore,
          estimatedTokens: totalTokens,
          estimatedCost: this.estimateCost(totalTokens, options.model),
          warnings: this.analyzeCode(generatedCode, options.framework),
          suggestions: this.generateSuggestions(generatedCode, options),
        };
      } catch (error) {
        lastError = error as Error;

        if (axios.isAxiosError(error) && error.code === 'ERR_CANCELED') {
          throw new DOMException('Generation cancelled', 'AbortError');
        }

        if (axios.isAxiosError(error)) {
          const axiosError = error as AxiosError<GeminiErrorResponse>;

          // Handle specific Gemini error codes
          if (axiosError.response?.status === 400) {
            const errorMessage = axiosError.response.data?.error?.message || 'Invalid request';
            
            // Check for safety blocking
            if (errorMessage.includes('SAFETY')) {
              throw new Error('Content was blocked by Gemini safety filters. Try adjusting your request.');
            }
            
            throw new Error(`Gemini API error: ${errorMessage}`);
          }
          
          if (axiosError.response?.status === 401 || axiosError.response?.status === 403) {
            throw new Error('Invalid Gemini API key. Please check your settings.');
          }
          
          if (axiosError.response?.status === 429) {
            // Rate limit - wait and retry
            if (attempt < this.maxRetries - 1) {
              await this.delay(this.retryDelay * (attempt + 1));
              continue;
            }
            throw new Error('Gemini rate limit exceeded. Please try again later.');
          }
          
          if (axiosError.response?.status === 503) {
            // Service unavailable - wait and retry
            if (attempt < this.maxRetries - 1) {
              await this.delay(this.retryDelay * (attempt + 1));
              continue;
            }
            throw new Error('Gemini service temporarily unavailable. Please try again.');
          }
        }
        
        // For other errors, retry with exponential backoff
        if (attempt < this.maxRetries - 1) {
          await this.delay(this.retryDelay * Math.pow(2, attempt));
          continue;
        }
      }
    }

    // If all retries failed
    Logger.getInstance().error('Gemini API error after retries', { error: lastError }, 'GeminiProvider');
    throw new Error(`Failed to generate tests with Gemini: ${lastError?.message || 'Unknown error'}`);
  }

  private extractGeneratedText(response: any): string {
    try {
      // Gemini response structure
      const candidates = response.candidates || [];
      if (candidates.length === 0) {
        return '';
      }
      
      const content = candidates[0].content;
      if (!content || !content.parts) {
        return '';
      }
      
      // Combine all text parts
      return content.parts
        .map((part: any) => part.text || '')
        .join('')
        .trim();
    } catch (error) {
      Logger.getInstance().error('Error extracting Gemini response', { error }, 'GeminiProvider');
      return '';
    }
  }

  private getModelName(model: string): string {
    const modelMap: Record<string, string> = {
      'gemini-2-5-pro': 'gemini-2.5-pro',
      'gemini-2-5-flash': 'gemini-2.5-flash',
    };

    return modelMap[model] || 'gemini-2.5-flash';
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  estimateCost(tokenCount: number, model: string): number {
    // Gemini pricing as of 2024 (approximate)
    const pricing: Record<string, { input: number; output: number }> = {
      'gemini-2-5-pro': { input: 0.00125, output: 0.00375 },
      'gemini-2-5-flash': { input: 0.00015, output: 0.0006 },
    };

    const modelPricing = pricing[model] || pricing['gemini-2-5-flash'];
    // Rough estimate: 60% input, 40% output
    const inputTokens = tokenCount * 0.6;
    const outputTokens = tokenCount * 0.4;
    
    return (inputTokens / 1000) * modelPricing.input + (outputTokens / 1000) * modelPricing.output;
  }

  countTokens(text: string): number {
    try {
      // Use gpt-tokenizer as approximation for Gemini
      const tokens = encode(text);
      return tokens.length;
    } catch (error) {
      // Fallback to rough estimation
      return Math.ceil(text.length / 4);
    }
  }

  private getMaxTokens(model: string): number {
    const limits: Record<string, number> = {
      'gemini-2-5-pro': 2097152,
      'gemini-2-5-flash': 1048576,
    };
    return limits[model] || 1048576;
  }

  private buildExhaustivePrompt(harData: HARData, options: GenerationOptions, authFlow?: AuthFlow, customAuthGuide?: string): string {
    const framework = options.framework;
    const entries = harData.entries;

    // Group by unique endpoints (GraphQL-aware)
    const uniqueEndpoints = new Map<string, typeof entries[0]>();
    entries.forEach(entry => {
      try {
        const url = new URL(entry.request.url);
        let signature = `${entry.request.method}:${normalizePath(url.pathname)}`;
        if (this.isGraphQLEndpoint(url.pathname, entry.request)) {
          const graphqlOperation = this.extractGraphQLOperation(entry.request);
          if (graphqlOperation) {
            signature = `${entry.request.method}:${url.pathname}:${graphqlOperation}`;
          }
        }
        if (!uniqueEndpoints.has(signature)) {
          uniqueEndpoints.set(signature, entry);
        }
      } catch {
        const signature = `${entry.request.method}:${entry.request.url}`;
        if (!uniqueEndpoints.has(signature)) {
          uniqueEndpoints.set(signature, entry);
        }
      }
    });

    let prompt = `üî•üî•üî• NUCLEAR ALERT - CRITICAL REQUIREMENT üî•üî•üî•

I AM PAYING FOR COMPLETE TEST GENERATION. INCOMPLETE RESPONSES WILL BE REJECTED.

YOU MUST GENERATE COMPLETE, FULLY-IMPLEMENTED ${framework} TEST CODE FOR ALL ${uniqueEndpoints.size} ENDPOINTS.

üö´ ABSOLUTELY FORBIDDEN - INSTANT REJECTION:
‚ùå "Continue adding more endpoint tests..."
‚ùå "Follow the same pattern for remaining endpoints"
‚ùå "Add more tests here" or "TODO: implement more tests"
‚ùå "Similar tests can be added for other endpoints"
‚ùå Any variation of "continue", "add more", "follow pattern"
‚ùå Stopping after generating only some endpoints

üî• MANDATORY REQUIREMENTS:
‚úÖ GENERATE ACTUAL WORKING CODE FOR ALL ${uniqueEndpoints.size} ENDPOINTS
‚úÖ Each endpoint gets a complete test suite with 10-15 real test cases
‚úÖ NO placeholder comments, NO template suggestions
‚úÖ Production-ready, runnable code that I can use immediately

Framework: ${framework}
${this.getFrameworkInstructions(framework)}

üî• CODE QUALITY REQUIREMENTS:

‚ö†Ô∏è IMPORTS & SETUP:
‚úÖ Include proper imports at the top
‚úÖ Define constants: BASE_URL, AUTH_URL
‚úÖ Use environment variables: process.env.BASE_URL || 'default_value'

‚ö†Ô∏è SYNTAX & STRUCTURE:
‚úÖ Use ONLY ${framework} syntax (NO mixing frameworks)
‚úÖ Proper bracket matching and indentation
‚úÖ ONE main test suite wrapping all endpoints
‚úÖ Use const for all declarations, NOT let or var

‚ö†Ô∏è TEST ORGANIZATION:
‚úÖ Clear, unique endpoint descriptions
‚úÖ Logical grouping by endpoint
‚úÖ No duplicate describe blocks
‚úÖ ALL test functions at the same nesting level within their endpoint suite

TEST DEPTH: ${options.testCoverage === 'minimal' ? 'MINIMAL ‚Äî Generate only happy-path tests (1-2 test cases per endpoint).' : options.testCoverage === 'exhaustive' ? 'EXHAUSTIVE ‚Äî Generate comprehensive tests covering happy path, error cases, edge cases, and all status codes (8+ test cases per endpoint).' : 'STANDARD ‚Äî Generate happy-path and basic error tests (3-5 test cases per endpoint).'}

TEST CATEGORIES TO INCLUDE:

1. ‚úÖ POSITIVE/HAPPY PATH TESTS:
   - Successful requests with valid data
   - Verify response structure and data types
   - Validate business logic and data relationships

`;

    let categoryNum = 2;

    if (options.includeErrorScenarios) {
      prompt += `${categoryNum}. ‚ùå NEGATIVE/ERROR TESTS:
   - 400 Bad Request - Invalid/malformed input
   - 401 Unauthorized - Missing/invalid auth
   - 403 Forbidden - Insufficient permissions
   - 404 Not Found - Non-existent resources
   - 409 Conflict - Duplicate/conflicting data
   - 422 Unprocessable Entity - Validation failures
   - 429 Too Many Requests - Rate limiting
   - 500 Internal Server Error - Server failures

`;
      categoryNum++;
    }

    if (options.includeEdgeCases) {
      prompt += `${categoryNum}. üîß EDGE CASES & BOUNDARY TESTS:
   - Empty strings, null, undefined values
   - Maximum length strings (10000+ chars)
   - Minimum/maximum numeric values (0, -1, MAX_INT)
   - Special characters: !@#$%^&*()<>?:"{}[]|\\
   - Unicode and emoji
   - Array boundaries (empty, 1 item, 1000+ items)
   - Pagination limits and offsets
   - Idempotency for PUT/DELETE

`;
      categoryNum++;
    }

    if (options.includeAuth) {
      prompt += `${categoryNum}. üîê AUTHENTICATION TESTS:
   - Proper token handling and chaining
   - Token expiration and refresh
   - Missing/invalid authentication headers
   - Role-based access control scenarios

`;
      categoryNum++;
    }

    if (options.includeSecurityTests) {
      prompt += `${categoryNum}. üîí SECURITY TESTS:
   - Authentication bypass attempts
   - CORS validation
   - XSS injection attempts
   - SQL injection attempts
   - Input sanitization verification
   - Sensitive data exposure checks

`;
      categoryNum++;
    }

    if (options.includePerformanceTests) {
      prompt += `${categoryNum}. ‚ö° PERFORMANCE TESTS:
   - Response time < 1000ms for GET
   - Response time < 2000ms for POST/PUT
   - Payload size validation
   - Timeout handling

`;
      categoryNum++;
    }

    if (options.generateMockData) {
      prompt += `${categoryNum}. üß™ MOCK DATA:
   - Generate realistic mock data
   - Use data-driven tests for multiple input combinations

`;
      categoryNum++;
    }

    if (options.includeIntegrationTests) {
      prompt += `${categoryNum}. üîó INTEGRATION TESTS:
   - Test multiple endpoints together in workflows
   - Verify data consistency across related endpoints

`;
    }

    // Authentication section
    if (authFlow) {
      prompt += this.generateAuthenticationSection(authFlow, framework, customAuthGuide);
    }

    prompt += `\n\nüéØ MANDATORY: GENERATE COMPLETE TESTS FOR ALL ${uniqueEndpoints.size} ENDPOINTS BELOW:\n`;

    // Per-endpoint detailed blocks
    Array.from(uniqueEndpoints.values()).forEach((entry, index) => {
      const url = new URL(entry.request.url);
      const method = entry.request.method;
      const isGraphQL = url.pathname.includes('graphql');
      const requestBody = entry.request.postData?.text;
      const responseBody = entry.response.content.text;
      const statusCode = entry.response.status;

      prompt += `
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üî• ENDPOINT ${index + 1}/${uniqueEndpoints.size}: ${method} ${url.pathname}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üåê REQUEST DETAILS:
Full URL: ${entry.request.url}
Method: ${method}
${url.search ? `Query Parameters: ${url.search}` : 'No query parameters'}

üîë REQUEST HEADERS:
${entry.request.headers && entry.request.headers.length > 0
  ? entry.request.headers.map((h: any) => `${h.name}: ${h.value}`).join('\n')
  : 'No headers captured'}

üç™ REQUEST COOKIES:
${entry.request.cookies && entry.request.cookies.length > 0
  ? entry.request.cookies.map((c: any) => `${c.name}=${c.value}`).join('; ')
  : 'No cookies'}

üì¶ REQUEST BODY:
${requestBody ? requestBody.substring(0, 1500) : 'No request body'}

üì• RESPONSE DETAILS:
Status: ${statusCode}
${entry.response.headers && entry.response.headers.length > 0
  ? `Response Headers:\n${entry.response.headers.map((h: any) => `${h.name}: ${h.value}`).join('\n')}`
  : 'No response headers'}

üç™ RESPONSE COOKIES:
${entry.response.cookies && entry.response.cookies.length > 0
  ? entry.response.cookies.map((c: any) => `${c.name}=${c.value}${c.domain ? `; Domain=${c.domain}` : ''}${c.httpOnly ? '; HttpOnly' : ''}${c.secure ? '; Secure' : ''}`).join('\n')
  : 'No response cookies'}

üì¶ RESPONSE BODY:
${responseBody ? responseBody.substring(0, 1500) : 'No response body'}

üö® TESTS FOR THIS ENDPOINT:
1. ‚úÖ HAPPY PATH TEST: Valid request ‚Üí ${statusCode}
${options.includeErrorScenarios ? `2. ‚ùå ERROR TESTS: 400, 401, 403, 404, 422, 500
   ${method !== 'GET' ? '- Test with invalid content-type headers' : ''}` : ''}
${options.includeEdgeCases ? `3. üîß EDGE CASES: Empty/null values, boundary values, special chars
   ${isGraphQL ? '- GraphQL-specific edge cases (query depth, invalid syntax)' : ''}` : ''}
${options.includeSecurityTests ? `4. üõ°Ô∏è SECURITY: XSS injection, SQL injection, auth bypass` : ''}

`;
    });

    // Inject syspro-inspired quality enhancement sections
    const pb = PromptBuilder.getInstance();
    prompt += pb.getCodeStructureTemplate(framework);
    prompt += pb.getSyntaxEnforcementSection(framework);
    prompt += pb.getInputValidationMatrix();
    prompt += pb.getSchemaValidationRequirement(framework);
    prompt += pb.getNamingAndAntiPatterns(framework);

    prompt += `

üî•üî•üî• FINAL ULTIMATUM - NO EXCEPTIONS üî•üî•üî•

I WILL REJECT ANY RESPONSE THAT:
‚ùå Contains "continue", "add more", "follow pattern", or "similar tests"
‚ùå Has fewer than ${uniqueEndpoints.size} describe blocks
‚ùå Stops generating after only some endpoints
‚ùå Uses placeholder or template comments

üéØ EXACT REQUIREMENTS:
1. Generate ${uniqueEndpoints.size} complete describe blocks (one per endpoint)
2. Each describe block contains 10-15 actual test cases
3. All code must be production-ready and runnable
4. No shortcuts, no placeholders, no "continue" instructions

${pb.getQualityGateSection()}

‚ö° GENERATE COMPLETE TESTS FOR ALL ${uniqueEndpoints.size} ENDPOINTS NOW - NO EXCEPTIONS:`;

    return prompt;
  }

  private generateAuthenticationSection(authFlow: AuthFlow, framework: string, customAuthGuide?: string): string {
    let authSection = `\n\nüîê AUTHENTICATION FLOW DETECTED:\n`;

    authSection += `Authentication Pattern: ${authFlow.authPattern}\n`;
    authSection += `Session Management: ${authFlow.sessionManagement}\n`;

    if (authFlow.loginEndpoint) {
      authSection += `Login Endpoint: ${authFlow.loginEndpoint.method} ${authFlow.loginEndpoint.url}\n`;
    }

    if (authFlow.authTokens.length > 0) {
      authSection += `Auth Tokens: ${authFlow.authTokens.map(t => `${t.type} (${t.source})`).join(', ')}\n`;
    }

    if (authFlow.sessionCookies.length > 0) {
      authSection += `Session Cookies: ${authFlow.sessionCookies.join(', ')}\n`;
    }

    if (authFlow.oauthFlow) {
      authSection += `OAuth Grant Type: ${authFlow.oauthFlow.grantType}\n`;
      authSection += `OAuth Scopes: ${authFlow.oauthFlow.scopes.join(', ')}\n`;
    }

    if (authFlow.jwtClaims) {
      authSection += `JWT Claims: ${Object.keys(authFlow.jwtClaims).join(', ')}\n`;
    }

    if (authFlow.refreshToken) {
      authSection += `Refresh Token Endpoint: ${authFlow.refreshToken.endpoint}\n`;
    }

    authSection += `Protected Endpoints: ${authFlow.protectedEndpoints.length}\n`;

    authSection += `\nüö® AUTHENTICATION REQUIREMENTS:\n`;
    authSection += `1. ‚úÖ Generate auth setup using ${authFlow.authPattern} pattern\n`;
    authSection += `2. ‚úÖ Extract tokens from login response and chain to subsequent requests\n`;
    authSection += `3. ‚úÖ Use environment variables for credentials\n`;
    authSection += `4. ‚úÖ Include beforeAll setup for authentication state\n`;
    authSection += `5. ‚úÖ Generate auth error tests (401, 403)\n`;
    authSection += `6. ‚úÖ Include proper cleanup in afterAll hooks\n`;

    if (customAuthGuide && customAuthGuide.trim()) {
      authSection += `\nüéØ CUSTOM AUTH GUIDE (HIGHEST PRIORITY):\n${customAuthGuide.trim()}\n`;
      authSection += `üö® Follow the custom guide above EXACTLY.\n`;
    }

    if (authFlow.loginEndpoint || authFlow.authTokens.length > 0) {
      try {
        const authFlowAnalyzer = AuthFlowAnalyzer.getInstance();
        const authSetup = authFlowAnalyzer.generateAuthSetup(authFlow, framework);
        if (authSetup) {
          authSection += `\nüìã AUTH SETUP TEMPLATE:\n\`\`\`\n${authSetup}\n\`\`\`\n`;
        }
      } catch {
        // AuthFlowAnalyzer may not be available
      }
    }

    return authSection;
  }

  private buildPrompt(harData: HARData, options: GenerationOptions): string {
    const framework = options.framework;
    const entries = harData.entries; // Process ALL entries

    let prompt = `Generate comprehensive ${framework} test code for the following API requests.\n\n`;
    
    // Add detailed framework instructions
    prompt += '## Framework Requirements\n';
    prompt += this.getFrameworkInstructions(framework);
    prompt += '\n\n';
    
    // Add test requirements
    prompt += '## Test Requirements\n';
    const requirements = [];
    
    if (options.includeAuth) {
      requirements.push('Authentication tests with proper token/session handling');
    }
    if (options.includeErrorScenarios) {
      requirements.push('Comprehensive error scenarios (4xx and 5xx status codes)');
    }
    if (options.includePerformanceTests) {
      requirements.push('Performance tests with response time assertions');
    }
    if (options.includeSecurityTests) {
      requirements.push('Security tests for common vulnerabilities');
    }
    if (options.generateMockData) {
      requirements.push('Generated mock data instead of production data');
    }
    if (options.includeEdgeCases) {
      requirements.push('Edge case tests (null values, empty arrays, boundary conditions)');
    }
    if (options.includeIntegrationTests) {
      requirements.push('Integration tests covering multiple endpoint interactions');
    }
    
    requirements.forEach(req => {
      prompt += `- ${req}\n`;
    });

    // TODO: Add authentication instructions when parameter scope issue is resolved
    
    prompt += '\n## API Endpoints\n';
    
    // Group and format requests
    const groupedRequests = this.groupRequestsByEndpoint(entries);
    
    for (const [endpoint, requests] of Object.entries(groupedRequests)) {
      prompt += `\n### ${endpoint}\n`;
      requests.forEach((entry, index) => {
        const url = new URL(entry.request.url);
        prompt += `${index + 1}. **${entry.request.method} ${url.pathname}**\n`;
        prompt += `   URL: ${entry.request.url}\n`;
        
        // Query parameters
        if (url.search) {
          prompt += `   Query Parameters: ${url.search}\n`;
        }
        
        // Request headers
        if (entry.request.headers && entry.request.headers.length > 0) {
          prompt += `   Request Headers:\n`;
          entry.request.headers.forEach((h: any) => {
            prompt += `      ${h.name}: ${h.value}\n`;
          });
        }
        
        // Request cookies
        if (entry.request.cookies && entry.request.cookies.length > 0) {
          prompt += `   Request Cookies: ${entry.request.cookies.map((c: any) => `${c.name}=${c.value}`).join('; ')}\n`;
        }
        
        // Request body
        if (entry.request.postData?.text) {
          const bodyPreview = entry.request.postData.text.substring(0, 300);
          prompt += `   Request Body: \`${bodyPreview}${entry.request.postData.text.length > 300 ? '...' : ''}\`\n`;
        }
        
        prompt += `   Response Status: ${entry.response.status}\n`;
        
        // Response headers
        if (entry.response.headers && entry.response.headers.length > 0) {
          prompt += `   Response Headers:\n`;
          entry.response.headers.forEach((h: any) => {
            prompt += `      ${h.name}: ${h.value}\n`;
          });
        }
        
        // Response cookies
        if (entry.response.cookies && entry.response.cookies.length > 0) {
          prompt += `   Response Cookies:\n`;
          entry.response.cookies.forEach((c: any) => {
            prompt += `      ${c.name}=${c.value}${c.domain ? `; Domain=${c.domain}` : ''}${c.httpOnly ? '; HttpOnly' : ''}${c.secure ? '; Secure' : ''}\n`;
          });
        }
        
        // Response body
        if (entry.response.content?.text) {
          const responsePreview = entry.response.content.text.substring(0, 300);
          prompt += `   Response Body: \`${responsePreview}${entry.response.content.text.length > 300 ? '...' : ''}\`\n`;
        }
      });
    }

    prompt += '\n## Code Generation Instructions\n';
    prompt += '1. Generate complete, runnable test code\n';
    prompt += '2. Include all necessary imports and dependencies\n';
    prompt += '3. Use descriptive test names that explain what is being tested\n';
    prompt += '4. Add comprehensive assertions for status codes, response bodies, and headers\n';
    prompt += '5. Include proper error handling and async/await usage\n';
    prompt += '6. Add setup and teardown hooks where appropriate\n';
    prompt += '7. Use environment variables for sensitive data\n';
    prompt += '8. Add comments for complex test logic\n';
    prompt += '9. Ensure tests are independent and can run in any order\n';
    prompt += '10. Follow best practices for the chosen testing framework\n';

    return prompt;
  }

  private groupRequestsByEndpoint(entries: any[]): Record<string, any[]> {
    const grouped: Record<string, any[]> = {};
    
    entries.forEach(entry => {
      try {
        const url = new URL(entry.request.url);
        const endpoint = `${url.pathname}`;
        if (!grouped[endpoint]) {
          grouped[endpoint] = [];
        }
        grouped[endpoint].push(entry);
      } catch (error) {
        // If URL parsing fails, use the full URL
        const endpoint = entry.request.url;
        if (!grouped[endpoint]) {
          grouped[endpoint] = [];
        }
        grouped[endpoint].push(entry);
      }
    });
    
    return grouped;
  }

  private getFrameworkInstructions(framework: string): string {
    const instructions: Record<string, string> = {
      jest: `Jest Testing Framework:
- Use test blocks for organizing test suites
- Use test with appropriate assertions
- Handle async operations with async or await`,
      
      playwright: `üö® CRITICAL: PLAYWRIGHT SYNTAX ONLY - ZERO TOLERANCE FOR JEST SYNTAX:
- MANDATORY: test.describe() for test suites (NEVER EVER use describe())
- MANDATORY: test() for individual tests (NEVER EVER use it())
- MANDATORY: test.beforeAll()/test.beforeEach() for setup (NEVER beforeAll/beforeEach)
- MANDATORY: test.afterAll()/test.afterEach() for cleanup (NEVER afterAll/afterEach)
- MANDATORY: import { test, expect } from '@playwright/test'
- Use { request } fixture for all API testing
- Use expect() with Playwright-specific matchers
- Add test.use() for global configuration
- ZERO mixing of Jest and Playwright syntax allowed
‚ùå INSTANT REJECTION: describe(), it(), beforeAll(), beforeEach(), afterAll(), afterEach()
‚úÖ ONLY ALLOWED: test.describe(), test(), test.beforeAll(), test.beforeEach(), test.afterAll(), test.afterEach()`,
      
      'mocha-chai': `Mocha with Chai:
- Use describe() for test suites
- Use it() for test cases
- Implement before()/beforeEach() hooks
- Implement after()/afterEach() hooks
- Use chai.expect() or chai.should() for assertions
- Use chai-http for HTTP requests
- Handle async with done callback or promises
- Set timeouts with this.timeout()`,
      
      cypress: `Cypress E2E Testing:
- Use describe() and it() blocks
- Use cy.request() for API testing
- Use cy.intercept() for request interception
- Implement proper assertions with should()
- Use cy.wrap() for promise handling
- Add custom commands in support files
- Use fixtures for test data
- Implement proper retry strategies`,
      
      puppeteer: `Puppeteer with Jest:
- Use describe() and test() blocks
- Initialize browser and page in beforeAll()
- Clean up in afterAll()
- Use page.evaluate() for executing in browser context
- Intercept requests with page.setRequestInterception()
- Take screenshots on failure
- Handle navigation and timeouts properly
- Use page.waitForResponse() for API calls`,
      
      vitest: `Vitest Testing Framework:
- Use describe() and it()/test() blocks
- Use vi.mock() for mocking modules
- Implement beforeAll()/beforeEach() hooks
- Implement afterAll()/afterEach() hooks
- Use expect() with Vitest matchers
- Handle async with async/await
- Use vi.spyOn() for spying on methods
- Add proper TypeScript types`,
      
      supertest: `Supertest API Testing:
- Use describe() and it() blocks
- Initialize app instance for testing
- Use supertest(app) for making requests
- Chain .expect() for assertions
- Use .send() for request bodies
- Use .set() for headers
- Handle async with async/await
- Implement proper error assertions`,
      
      postman: `Postman Collection:
- Create proper collection structure
- Add collection variables
- Implement pre-request scripts
- Write test scripts using pm.test()
- Use pm.expect() for assertions
- Add environment variables
- Include response examples
- Document each request
- Add proper authentication`,
      
      restassured: `üö® REST ASSURED JAVA FRAMEWORK - ABSOLUTELY NO JAVASCRIPT:
- MANDATORY: Generate complete Java test class using REST Assured library
- MANDATORY: Use @Test annotations from TestNG or JUnit frameworks
- MANDATORY: Import static io.restassured.RestAssured.* and static org.hamcrest.Matchers.*
- MANDATORY: Use given().when().then() BDD pattern for ALL API calls
- MANDATORY: Use RequestSpecification for common request configurations
- Use statusCode(), body(), header() methods for response validations
- Use Hamcrest matchers: equalTo(), notNullValue(), hasSize(), containsString(), etc.
- Include @BeforeClass for test setup and @AfterClass for cleanup
- Use Response response = given().when().get() for complex validations
‚ùå STRICTLY FORBIDDEN: Any JavaScript syntax, describe(), it(), expect(), async/await, const, let
‚úÖ ONLY ALLOWED: Java syntax, public class, @Test, given().when().then(), import statements`,
    };

    return instructions[framework] || instructions.jest;
  }

  private calculateQualityScore(code: string, harData: HARData): number {
    let score = 5; // Base score

    // Check endpoint coverage
    const maxEndpoints = Math.min(harData.entries.length, 50);
    const coveredEndpoints = harData.entries.slice(0, maxEndpoints).filter(entry => {
      try {
        const url = new URL(entry.request.url);
        return code.includes(url.pathname) || code.includes(entry.request.url);
      } catch {
        return code.includes(entry.request.url);
      }
    }).length;
    
    score += Math.min(2, (coveredEndpoints / maxEndpoints) * 2);

    // Check for quality indicators
    const qualityIndicators = [
      { pattern: /expect|assert|should/, weight: 0.5 },
      { pattern: /describe|suite|context/, weight: 0.5 },
      { pattern: /async|await|\.then/, weight: 0.5 },
      { pattern: /try|catch|\.catch/, weight: 0.5 },
      { pattern: /before|setup|initialize/, weight: 0.3 },
      { pattern: /after|teardown|cleanup/, weight: 0.3 },
      { pattern: /mock|stub|spy/, weight: 0.4 },
    ];

    qualityIndicators.forEach(({ pattern, weight }) => {
      if (pattern.test(code)) {
        score += weight;
      }
    });

    return Math.min(10, score);
  }

  private analyzeCode(code: string, framework?: string): string[] {
    const warnings: string[] = [];

    // Framework-aware checks
    const issues = [
      {
        check: () => !this.detectAssertions(code, framework),
        message: 'No assertions found in generated tests',
      },
      {
        check: () => /localhost|127\.0\.0\.1/.test(code) && !/process\.env|import\.meta\.env/.test(code),
        message: 'Tests contain hardcoded localhost URLs without environment variables',
      },
      {
        check: () => /Bearer\s+[A-Za-z0-9]/.test(code) && !/process\.env|import\.meta\.env|\$\{/.test(code),
        message: 'API keys or tokens may be hardcoded',
      },
      {
        check: () => code.length < 300,
        message: 'Generated tests seem incomplete or too short',
      },
      {
        check: () => !this.detectTestOrganization(code, framework),
        message: 'Tests lack proper organization structure',
      },
      {
        check: () => !this.detectAsyncHandling(code, framework),
        message: 'Tests may not handle asynchronous operations properly',
      },
    ];

    issues.forEach(({ check, message }) => {
      if (check()) {
        warnings.push(message);
      }
    });

    return warnings;
  }

  private detectAssertions(code: string, framework?: string): boolean {
    switch (framework) {
      case 'restassured':
        return /assertThat|statusCode|equalTo|notNullValue|containsString/.test(code);
      case 'postman':
        return /pm\.test|pm\.expect/.test(code);
      default:
        return /expect|assert|should/.test(code);
    }
  }

  private detectTestOrganization(code: string, framework?: string): boolean {
    switch (framework) {
      case 'restassured':
        return /@Test.*public.*void/.test(code) && /public class/.test(code);
      case 'postman':
        return /"info".*"item"/.test(code);
      default:
        return /describe|suite|test\.describe/.test(code);
    }
  }

  private detectAsyncHandling(code: string, framework?: string): boolean {
    switch (framework) {
      case 'restassured':
        // REST Assured handles async internally
        return /given\(\)|when\(\)|then\(\)/.test(code);
      case 'postman':
        // Postman collections don't need explicit async handling
        return true;
      default:
        return /async|await|Promise|\.then/.test(code);
    }
  }

  private generateSuggestions(code: string, options: GenerationOptions): string[] {
    const suggestions: string[] = [];

    // Framework-specific suggestions
    const frameworkSuggestions = [
      {
        condition: () => !(/describe|suite/.test(code)) && options.framework !== 'postman',
        message: 'Organize tests in describe blocks for better structure and readability',
      },
      {
        condition: () => !(/timeout|setTimeout/.test(code)),
        message: 'Add timeout configurations for long-running API tests',
      },
      {
        condition: () => !(/before|setup/.test(code)),
        message: 'Add setup hooks for test initialization and data preparation',
      },
      {
        condition: () => !(/after|teardown|cleanup/.test(code)),
        message: 'Add cleanup hooks to prevent test pollution and resource leaks',
      },
      {
        condition: () => options.includePerformanceTests && !(/performance|Date\.now|hrtime/.test(code)),
        message: 'Add explicit performance measurements using performance.now() or process.hrtime()',
      },
      {
        condition: () => !(/mock|stub|spy|nock/.test(code)),
        message: 'Consider mocking external dependencies for more reliable tests',
      },
      {
        condition: () => !(/\.env|process\.env|import\.meta\.env/.test(code)),
        message: 'Use environment variables for configuration and sensitive data',
      },
      {
        condition: () => options.includeErrorScenarios && !(/400|401|403|404|500/.test(code)),
        message: 'Add more comprehensive error scenario tests for different HTTP status codes',
      },
    ];

    frameworkSuggestions.forEach(({ condition, message }) => {
      if (condition()) {
        suggestions.push(message);
      }
    });

    return suggestions;
  }

  private isGraphQLEndpoint(pathname: string, request: any): boolean {
    return pathname.includes('graphql') || pathname.includes('gql') || 
           (request.postData?.text && this.looksLikeGraphQL(request.postData.text));
  }

  private looksLikeGraphQL(requestBody: any): boolean {
    if (!requestBody) return false;
    
    try {
      const bodyStr = typeof requestBody === 'string' ? requestBody : JSON.stringify(requestBody);
      const body = typeof requestBody === 'object' ? requestBody : JSON.parse(bodyStr);
      
      // Check for GraphQL query patterns
      return !!(body.query || body.operationName || body.variables || 
                bodyStr.includes('query ') || bodyStr.includes('mutation ') || 
                bodyStr.includes('subscription '));
    } catch {
      return false;
    }
  }

  private extractGraphQLOperation(request: any): string | null {
    const requestBody = request.postData?.text;
    if (!requestBody) return null;
    
    try {
      const bodyStr = typeof requestBody === 'string' ? requestBody : JSON.stringify(requestBody);
      const body = typeof requestBody === 'object' ? requestBody : JSON.parse(bodyStr);
      
      // Priority 1: Use operationName if available
      if (body.operationName && typeof body.operationName === 'string') {
        return body.operationName;
      }
      
      // Priority 2: Extract operation name from query string
      if (body.query && typeof body.query === 'string') {
        const queryMatch = body.query.match(/(?:query|mutation|subscription)\s+([a-zA-Z][a-zA-Z0-9_]*)/);
        if (queryMatch && queryMatch[1]) {
          return queryMatch[1];
        }
        
        // Priority 3: Use operation type + hash for unnamed operations
        const operationType = body.query.trim().match(/^(query|mutation|subscription)/);
        if (operationType) {
          const queryHash = this.simpleHash(body.query);
          return `${operationType[1]}_${queryHash}`;
        }
      }
      
      // Priority 4: Fallback to request body hash
      const bodyHash = this.simpleHash(bodyStr);
      return `operation_${bodyHash}`;
      
    } catch (error) {
      return null;
    }
  }

  private simpleHash(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(16).substring(0, 8);
  }
}