import axios, { AxiosError } from 'axios';
import { encode } from 'gpt-tokenizer';
import { HARData, GenerationOptions, GeneratedTest } from '@/types';
import { LLMProvider } from '../LLMService';
import { AuthFlow } from '../../AuthFlowAnalyzer';

interface GeminiErrorResponse {
  error?: {
    message: string;
    status: string;
    code: number;
  };
}

export class GeminiProvider implements LLMProvider {
  private apiKey: string = '';
  private baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
  private maxRetries = 3;
  private retryDelay = 1000;

  setApiKey(key: string): void {
    this.apiKey = key;
  }

  async generateTests(
    harData: HARData,
    options: GenerationOptions,
    authFlow?: AuthFlow
  ): Promise<GeneratedTest> {
    if (!this.apiKey) {
      throw new Error('Gemini API key not configured');
    }

    const prompt = this.buildExhaustivePrompt(harData, options, authFlow);
    const promptTokens = this.countTokens(prompt);

    // Check token limits - leave room for complete responses
    const modelLimit = this.getMaxTokens(options.model);
    if (promptTokens > modelLimit * 0.4) { // Leave 60% for response
      throw new Error(`Prompt too large for ${options.model}. Consider reducing the number of requests.`);
    }

    let lastError: Error | null = null;
    
    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        const modelName = this.getModelName(options.model);
        const response = await axios.post(
          `${this.baseUrl}/models/${modelName}:generateContent?key=${this.apiKey}`,
          {
            contents: [
              {
                parts: [
                  {
                    text: `You are an expert API test engineer. Generate clean, production-ready test code.\n\n${prompt}`,
                  },
                ],
              },
            ],
            generationConfig: {
              temperature: 0.7,
              topK: 40,
              topP: 0.95,
              maxOutputTokens: Math.min(65536, Math.floor((modelLimit - promptTokens) * 0.95)), // Use up to 95% of remaining tokens
            },
            safetySettings: [
              {
                category: 'HARM_CATEGORY_HARASSMENT',
                threshold: 'BLOCK_NONE',
              },
              {
                category: 'HARM_CATEGORY_HATE_SPEECH',
                threshold: 'BLOCK_NONE',
              },
              {
                category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
                threshold: 'BLOCK_NONE',
              },
              {
                category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
                threshold: 'BLOCK_NONE',
              },
            ],
          },
          {
            headers: {
              'Content-Type': 'application/json',
            },
            timeout: 60000,
          }
        );

        // Extract generated text from Gemini response
        const generatedCode = this.extractGeneratedText(response.data);
        if (!generatedCode) {
          throw new Error('No content generated by Gemini');
        }

        const completionTokens = this.countTokens(generatedCode);
        const totalTokens = promptTokens + completionTokens;
        const qualityScore = this.calculateQualityScore(generatedCode, harData);

        return {
          id: `test_${Date.now()}`,
          framework: options.framework,
          code: generatedCode,
          qualityScore,
          estimatedTokens: totalTokens,
          estimatedCost: this.estimateCost(totalTokens, options.model),
          warnings: this.analyzeCode(generatedCode),
          suggestions: this.generateSuggestions(generatedCode, options),
        };
      } catch (error) {
        lastError = error as Error;
        
        if (axios.isAxiosError(error)) {
          const axiosError = error as AxiosError<GeminiErrorResponse>;
          
          // Handle specific Gemini error codes
          if (axiosError.response?.status === 400) {
            const errorMessage = axiosError.response.data?.error?.message || 'Invalid request';
            
            // Check for safety blocking
            if (errorMessage.includes('SAFETY')) {
              throw new Error('Content was blocked by Gemini safety filters. Try adjusting your request.');
            }
            
            throw new Error(`Gemini API error: ${errorMessage}`);
          }
          
          if (axiosError.response?.status === 401 || axiosError.response?.status === 403) {
            throw new Error('Invalid Gemini API key. Please check your settings.');
          }
          
          if (axiosError.response?.status === 429) {
            // Rate limit - wait and retry
            if (attempt < this.maxRetries - 1) {
              await this.delay(this.retryDelay * (attempt + 1));
              continue;
            }
            throw new Error('Gemini rate limit exceeded. Please try again later.');
          }
          
          if (axiosError.response?.status === 503) {
            // Service unavailable - wait and retry
            if (attempt < this.maxRetries - 1) {
              await this.delay(this.retryDelay * (attempt + 1));
              continue;
            }
            throw new Error('Gemini service temporarily unavailable. Please try again.');
          }
        }
        
        // For other errors, retry with exponential backoff
        if (attempt < this.maxRetries - 1) {
          await this.delay(this.retryDelay * Math.pow(2, attempt));
          continue;
        }
      }
    }

    // If all retries failed
    console.error('Gemini API error after retries:', lastError);
    throw new Error(`Failed to generate tests with Gemini: ${lastError?.message || 'Unknown error'}`);
  }

  private extractGeneratedText(response: any): string {
    try {
      // Gemini response structure
      const candidates = response.candidates || [];
      if (candidates.length === 0) {
        return '';
      }
      
      const content = candidates[0].content;
      if (!content || !content.parts) {
        return '';
      }
      
      // Combine all text parts
      return content.parts
        .map((part: any) => part.text || '')
        .join('')
        .trim();
    } catch (error) {
      console.error('Error extracting Gemini response:', error);
      return '';
    }
  }

  private getModelName(model: string): string {
    // Map user-friendly names to Gemini API model names
    const modelMap: Record<string, string> = {
      'gemini-1.5-pro-latest': 'gemini-1.5-pro-latest',
      'gemini-1.5-flash': 'gemini-1.5-flash',
      'gemini-1.5-flash-8b': 'gemini-1.5-flash-8b',
      'gemini-pro': 'gemini-pro',
      'gemini-pro-vision': 'gemini-pro-vision',
    };
    
    return modelMap[model] || 'gemini-1.5-flash';
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  estimateCost(tokenCount: number, model: string): number {
    // Gemini pricing as of 2024 (approximate)
    const pricing: Record<string, { input: number; output: number }> = {
      'gemini-1.5-pro': { input: 0.00125, output: 0.00375 }, // per 1k tokens
      'gemini-1.5-flash': { input: 0.00015, output: 0.0006 },
      'gemini-pro': { input: 0.0005, output: 0.0015 },
    };
    
    const modelPricing = pricing[model] || pricing['gemini-1.5-flash'];
    // Rough estimate: 60% input, 40% output
    const inputTokens = tokenCount * 0.6;
    const outputTokens = tokenCount * 0.4;
    
    return (inputTokens / 1000) * modelPricing.input + (outputTokens / 1000) * modelPricing.output;
  }

  countTokens(text: string): number {
    try {
      // Use gpt-tokenizer as approximation for Gemini
      const tokens = encode(text);
      return tokens.length;
    } catch (error) {
      // Fallback to rough estimation
      return Math.ceil(text.length / 4);
    }
  }

  private getMaxTokens(model: string): number {
    const limits: Record<string, number> = {
      'gemini-2-5-pro': 2097152,        // Latest Gemini 2.5 Pro - 2M context
      'gemini-2-5-flash': 1048576,      // Latest Gemini 2.5 Flash - 1M context
      'gemini-1.5-pro-latest': 2097152, // Legacy - 2M context window
      'gemini-1.5-flash': 1048576,      // Legacy - 1M context window
      'gemini-1.5-flash-8b': 1048576,   // Legacy - 1M context window
      'gemini-pro': 32768,              // Legacy
    };
    return limits[model] || 32768;
  }

  private buildExhaustivePrompt(harData: HARData, options: GenerationOptions, authFlow?: AuthFlow): string {
    const framework = options.framework;
    const entries = harData.entries; // Process ALL entries

    // Group by unique endpoints
    const uniqueEndpoints = new Map<string, any>();
    entries.forEach(entry => {
      try {
        const url = new URL(entry.request.url);
        const signature = `${entry.request.method}:${url.pathname}`;
        if (!uniqueEndpoints.has(signature)) {
          uniqueEndpoints.set(signature, entry);
        }
      } catch {
        const signature = `${entry.request.method}:${entry.request.url}`;
        if (!uniqueEndpoints.has(signature)) {
          uniqueEndpoints.set(signature, entry);
        }
      }
    });

    let prompt = `ðŸš¨ CRITICAL: Generate COMPLETE ${framework} test code for ALL ${uniqueEndpoints.size} API endpoints.

âš ï¸  NO placeholder comments like "// Continue adding more tests..."
âš ï¸  GENERATE COMPLETE TEST CODE FOR EVERY SINGLE ENDPOINT
âš ï¸  Each endpoint needs 10-15 individual test cases

${this.getFrameworkInstructions(framework)}

ðŸŽ¯ ENDPOINTS TO FULLY TEST (${uniqueEndpoints.size} total):

`;

    Array.from(uniqueEndpoints.values()).forEach((entry, index) => {
      const url = new URL(entry.request.url);
      const method = entry.request.method;
      const statusCode = entry.response.status;
      
      prompt += `
${index + 1}. ${method} ${url.pathname} â†’ ${statusCode}
   URL: ${entry.request.url}
   ðŸš¨ MUST GENERATE: Complete describe() block with 10-15 test() cases
   - Happy path, errors (400,401,403,404,500), edge cases, security tests
`;
    });

    prompt += `

ðŸš¨ FINAL REQUIREMENTS:
âœ… Generate ${uniqueEndpoints.size} complete describe() blocks
âŒ No "// Continue..." placeholder comments
âœ… Production-ready, runnable ${framework} test code
âœ… Include setup/teardown hooks

GENERATE COMPLETE TEST CODE NOW:`;

    return prompt;
  }

  private buildPrompt(harData: HARData, options: GenerationOptions): string {
    const framework = options.framework;
    const entries = harData.entries; // Process ALL entries

    let prompt = `Generate comprehensive ${framework} test code for the following API requests.\n\n`;
    
    // Add detailed framework instructions
    prompt += '## Framework Requirements\n';
    prompt += this.getFrameworkInstructions(framework);
    prompt += '\n\n';
    
    // Add test requirements
    prompt += '## Test Requirements\n';
    const requirements = [];
    
    if (options.includeAuth) {
      requirements.push('Authentication tests with proper token/session handling');
    }
    if (options.includeErrorScenarios) {
      requirements.push('Comprehensive error scenarios (4xx and 5xx status codes)');
    }
    if (options.includePerformanceTests) {
      requirements.push('Performance tests with response time assertions');
    }
    if (options.includeSecurityTests) {
      requirements.push('Security tests for common vulnerabilities');
    }
    if (options.generateMockData) {
      requirements.push('Generated mock data instead of production data');
    }
    if (options.includeEdgeCases) {
      requirements.push('Edge case tests (null values, empty arrays, boundary conditions)');
    }
    if (options.includeIntegrationTests) {
      requirements.push('Integration tests covering multiple endpoint interactions');
    }
    
    requirements.forEach(req => {
      prompt += `- ${req}\n`;
    });
    
    prompt += '\n## API Endpoints\n';
    
    // Group and format requests
    const groupedRequests = this.groupRequestsByEndpoint(entries);
    
    for (const [endpoint, requests] of Object.entries(groupedRequests)) {
      prompt += `\n### ${endpoint}\n`;
      requests.forEach((entry, index) => {
        prompt += `${index + 1}. **${entry.request.method}**\n`;
        
        // Add request details
        if (entry.request.headers && entry.request.headers.length > 0) {
          const authHeader = entry.request.headers.find((h: any) => 
            h.name.toLowerCase() === 'authorization'
          );
          if (authHeader) {
            prompt += `   - Auth: ${authHeader.value.substring(0, 20)}...\n`;
          }
        }
        
        if (entry.request.postData?.text) {
          const bodyPreview = entry.request.postData.text.substring(0, 150);
          prompt += `   - Request Body: \`${bodyPreview}...\`\n`;
        }
        
        prompt += `   - Response Status: ${entry.response.status}\n`;
        
        if (entry.response.content?.text) {
          const responsePreview = entry.response.content.text.substring(0, 150);
          prompt += `   - Response Body: \`${responsePreview}...\`\n`;
        }
      });
    }

    prompt += '\n## Code Generation Instructions\n';
    prompt += '1. Generate complete, runnable test code\n';
    prompt += '2. Include all necessary imports and dependencies\n';
    prompt += '3. Use descriptive test names that explain what is being tested\n';
    prompt += '4. Add comprehensive assertions for status codes, response bodies, and headers\n';
    prompt += '5. Include proper error handling and async/await usage\n';
    prompt += '6. Add setup and teardown hooks where appropriate\n';
    prompt += '7. Use environment variables for sensitive data\n';
    prompt += '8. Add comments for complex test logic\n';
    prompt += '9. Ensure tests are independent and can run in any order\n';
    prompt += '10. Follow best practices for the chosen testing framework\n';

    return prompt;
  }

  private groupRequestsByEndpoint(entries: any[]): Record<string, any[]> {
    const grouped: Record<string, any[]> = {};
    
    entries.forEach(entry => {
      try {
        const url = new URL(entry.request.url);
        const endpoint = `${url.pathname}`;
        if (!grouped[endpoint]) {
          grouped[endpoint] = [];
        }
        grouped[endpoint].push(entry);
      } catch (error) {
        // If URL parsing fails, use the full URL
        const endpoint = entry.request.url;
        if (!grouped[endpoint]) {
          grouped[endpoint] = [];
        }
        grouped[endpoint].push(entry);
      }
    });
    
    return grouped;
  }

  private getFrameworkInstructions(framework: string): string {
    const instructions: Record<string, string> = {
      jest: `Jest Testing Framework:
- Use describe() blocks for organizing test suites
- Use it() or test() for individual test cases
- Implement beforeAll()/beforeEach() for setup
- Implement afterAll()/afterEach() for cleanup
- Use expect() with appropriate matchers
- Handle async operations with async/await
- Use jest.mock() for mocking dependencies
- Set appropriate timeouts with jest.setTimeout()`,
      
      playwright: `Playwright Test Framework:
- Use test.describe() for test suites
- Use test() for individual tests
- Use test.beforeAll()/test.beforeEach() for setup
- Use test.afterAll()/test.afterEach() for cleanup
- Use request context for API testing
- Implement proper error handling
- Use expect() with Playwright matchers
- Add test.use() for configuration`,
      
      'mocha-chai': `Mocha with Chai:
- Use describe() for test suites
- Use it() for test cases
- Implement before()/beforeEach() hooks
- Implement after()/afterEach() hooks
- Use chai.expect() or chai.should() for assertions
- Use chai-http for HTTP requests
- Handle async with done callback or promises
- Set timeouts with this.timeout()`,
      
      cypress: `Cypress E2E Testing:
- Use describe() and it() blocks
- Use cy.request() for API testing
- Use cy.intercept() for request interception
- Implement proper assertions with should()
- Use cy.wrap() for promise handling
- Add custom commands in support files
- Use fixtures for test data
- Implement proper retry strategies`,
      
      puppeteer: `Puppeteer with Jest:
- Use describe() and test() blocks
- Initialize browser and page in beforeAll()
- Clean up in afterAll()
- Use page.evaluate() for executing in browser context
- Intercept requests with page.setRequestInterception()
- Take screenshots on failure
- Handle navigation and timeouts properly
- Use page.waitForResponse() for API calls`,
      
      vitest: `Vitest Testing Framework:
- Use describe() and it()/test() blocks
- Use vi.mock() for mocking modules
- Implement beforeAll()/beforeEach() hooks
- Implement afterAll()/afterEach() hooks
- Use expect() with Vitest matchers
- Handle async with async/await
- Use vi.spyOn() for spying on methods
- Add proper TypeScript types`,
      
      supertest: `Supertest API Testing:
- Use describe() and it() blocks
- Initialize app instance for testing
- Use supertest(app) for making requests
- Chain .expect() for assertions
- Use .send() for request bodies
- Use .set() for headers
- Handle async with async/await
- Implement proper error assertions`,
      
      postman: `Postman Collection:
- Create proper collection structure
- Add collection variables
- Implement pre-request scripts
- Write test scripts using pm.test()
- Use pm.expect() for assertions
- Add environment variables
- Include response examples
- Document each request
- Add proper authentication`,
    };

    return instructions[framework] || instructions.jest;
  }

  private calculateQualityScore(code: string, harData: HARData): number {
    let score = 5; // Base score

    // Check endpoint coverage
    const maxEndpoints = Math.min(harData.entries.length, 50);
    const coveredEndpoints = harData.entries.slice(0, maxEndpoints).filter(entry => {
      try {
        const url = new URL(entry.request.url);
        return code.includes(url.pathname) || code.includes(entry.request.url);
      } catch {
        return code.includes(entry.request.url);
      }
    }).length;
    
    score += Math.min(2, (coveredEndpoints / maxEndpoints) * 2);

    // Check for quality indicators
    const qualityIndicators = [
      { pattern: /expect|assert|should/, weight: 0.5 },
      { pattern: /describe|suite|context/, weight: 0.5 },
      { pattern: /async|await|\.then/, weight: 0.5 },
      { pattern: /try|catch|\.catch/, weight: 0.5 },
      { pattern: /before|setup|initialize/, weight: 0.3 },
      { pattern: /after|teardown|cleanup/, weight: 0.3 },
      { pattern: /mock|stub|spy/, weight: 0.4 },
    ];

    qualityIndicators.forEach(({ pattern, weight }) => {
      if (pattern.test(code)) {
        score += weight;
      }
    });

    return Math.min(10, score);
  }

  private analyzeCode(code: string): string[] {
    const warnings: string[] = [];

    // Check for common issues
    const issues = [
      {
        check: () => !(/expect|assert|should/.test(code)),
        message: 'No assertions found in generated tests',
      },
      {
        check: () => /localhost|127\.0\.0\.1/.test(code) && !/process\.env|import\.meta\.env/.test(code),
        message: 'Tests contain hardcoded localhost URLs without environment variables',
      },
      {
        check: () => /Bearer\s+[A-Za-z0-9]/.test(code) && !/process\.env|import\.meta\.env|\$\{/.test(code),
        message: 'API keys or tokens may be hardcoded',
      },
      {
        check: () => code.length < 300,
        message: 'Generated tests seem incomplete or too short',
      },
      {
        check: () => !(/describe|suite|test\.describe/.test(code)),
        message: 'Tests lack proper organization structure',
      },
      {
        check: () => !(/async|await|Promise|\.then/.test(code)),
        message: 'Tests may not handle asynchronous operations properly',
      },
    ];

    issues.forEach(({ check, message }) => {
      if (check()) {
        warnings.push(message);
      }
    });

    return warnings;
  }

  private generateSuggestions(code: string, options: GenerationOptions): string[] {
    const suggestions: string[] = [];

    // Framework-specific suggestions
    const frameworkSuggestions = [
      {
        condition: () => !(/describe|suite/.test(code)) && options.framework !== 'postman',
        message: 'Organize tests in describe blocks for better structure and readability',
      },
      {
        condition: () => !(/timeout|setTimeout/.test(code)),
        message: 'Add timeout configurations for long-running API tests',
      },
      {
        condition: () => !(/before|setup/.test(code)),
        message: 'Add setup hooks for test initialization and data preparation',
      },
      {
        condition: () => !(/after|teardown|cleanup/.test(code)),
        message: 'Add cleanup hooks to prevent test pollution and resource leaks',
      },
      {
        condition: () => options.includePerformanceTests && !(/performance|Date\.now|hrtime/.test(code)),
        message: 'Add explicit performance measurements using performance.now() or process.hrtime()',
      },
      {
        condition: () => !(/mock|stub|spy|nock/.test(code)),
        message: 'Consider mocking external dependencies for more reliable tests',
      },
      {
        condition: () => !(/\.env|process\.env|import\.meta\.env/.test(code)),
        message: 'Use environment variables for configuration and sensitive data',
      },
      {
        condition: () => options.includeErrorScenarios && !(/400|401|403|404|500/.test(code)),
        message: 'Add more comprehensive error scenario tests for different HTTP status codes',
      },
    ];

    frameworkSuggestions.forEach(({ condition, message }) => {
      if (condition()) {
        suggestions.push(message);
      }
    });

    return suggestions;
  }
}