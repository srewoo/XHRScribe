import axios, { AxiosError } from 'axios';
import { encode } from 'gpt-tokenizer';
import { HARData, GenerationOptions, GeneratedTest } from '@/types';
import { LLMProvider } from '../LLMService';
import { AuthFlow } from '../../AuthFlowAnalyzer';
import { PromptBuilder } from '../PromptBuilder';

interface GeminiErrorResponse {
  error?: {
    message: string;
    status: string;
    code: number;
  };
}

export class GeminiProvider implements LLMProvider {
  private apiKey: string = '';
  private baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
  private maxRetries = 3;
  private retryDelay = 1000;
  private promptBuilder: PromptBuilder = PromptBuilder.getInstance();

  setApiKey(key: string): void {
    this.apiKey = key;
  }

  async generateTests(
    harData: HARData,
    options: GenerationOptions,
    authFlow?: AuthFlow,
    customAuthGuide?: string
  ): Promise<GeneratedTest> {
    if (!this.apiKey) {
      throw new Error('Gemini API key not configured');
    }

    // Use standardized prompt for consistency if requested
    const prompt = (options as any).useStandardizedPrompt
      ? this.promptBuilder.buildStandardizedPrompt(harData, options, authFlow, customAuthGuide)
      : this.buildExhaustivePrompt(harData, options, authFlow, customAuthGuide);
    const promptTokens = this.countTokens(prompt);

    // Check token limits - leave room for complete responses
    const modelLimit = this.getMaxTokens(options.model);
    if (promptTokens > modelLimit * 0.4) { // Leave 60% for response
      throw new Error(`Prompt too large for ${options.model}. Consider reducing the number of requests.`);
    }

    let lastError: Error | null = null;
    
    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        const modelName = this.getModelName(options.model);
        const response = await axios.post(
          `${this.baseUrl}/models/${modelName}:generateContent?key=${this.apiKey}`,
          {
            contents: [
              {
                parts: [
                  {
                    text: `You are an expert API test engineer. Generate clean, production-ready test code.\n\n${prompt}`,
                  },
                ],
              },
            ],
            generationConfig: {
              temperature: 0.7,
              topK: 40,
              topP: 0.95,
              maxOutputTokens: Math.min(65536, Math.floor((modelLimit - promptTokens) * 0.95)), // Use up to 95% of remaining tokens
            },
            safetySettings: [
              {
                category: 'HARM_CATEGORY_HARASSMENT',
                threshold: 'BLOCK_NONE',
              },
              {
                category: 'HARM_CATEGORY_HATE_SPEECH',
                threshold: 'BLOCK_NONE',
              },
              {
                category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
                threshold: 'BLOCK_NONE',
              },
              {
                category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
                threshold: 'BLOCK_NONE',
              },
            ],
          },
          {
            headers: {
              'Content-Type': 'application/json',
            },
            timeout: 60000,
          }
        );

        // Extract generated text from Gemini response
        const generatedCode = this.extractGeneratedText(response.data);
        if (!generatedCode) {
          throw new Error('No content generated by Gemini');
        }

        const completionTokens = this.countTokens(generatedCode);
        const totalTokens = promptTokens + completionTokens;
        const qualityScore = this.calculateQualityScore(generatedCode, harData);

        return {
          id: `test_${Date.now()}`,
          framework: options.framework,
          code: generatedCode,
          qualityScore,
          estimatedTokens: totalTokens,
          estimatedCost: this.estimateCost(totalTokens, options.model),
          warnings: this.analyzeCode(generatedCode),
          suggestions: this.generateSuggestions(generatedCode, options),
        };
      } catch (error) {
        lastError = error as Error;
        
        if (axios.isAxiosError(error)) {
          const axiosError = error as AxiosError<GeminiErrorResponse>;
          
          // Handle specific Gemini error codes
          if (axiosError.response?.status === 400) {
            const errorMessage = axiosError.response.data?.error?.message || 'Invalid request';
            
            // Check for safety blocking
            if (errorMessage.includes('SAFETY')) {
              throw new Error('Content was blocked by Gemini safety filters. Try adjusting your request.');
            }
            
            throw new Error(`Gemini API error: ${errorMessage}`);
          }
          
          if (axiosError.response?.status === 401 || axiosError.response?.status === 403) {
            throw new Error('Invalid Gemini API key. Please check your settings.');
          }
          
          if (axiosError.response?.status === 429) {
            // Rate limit - wait and retry
            if (attempt < this.maxRetries - 1) {
              await this.delay(this.retryDelay * (attempt + 1));
              continue;
            }
            throw new Error('Gemini rate limit exceeded. Please try again later.');
          }
          
          if (axiosError.response?.status === 503) {
            // Service unavailable - wait and retry
            if (attempt < this.maxRetries - 1) {
              await this.delay(this.retryDelay * (attempt + 1));
              continue;
            }
            throw new Error('Gemini service temporarily unavailable. Please try again.');
          }
        }
        
        // For other errors, retry with exponential backoff
        if (attempt < this.maxRetries - 1) {
          await this.delay(this.retryDelay * Math.pow(2, attempt));
          continue;
        }
      }
    }

    // If all retries failed
    console.error('Gemini API error after retries:', lastError);
    throw new Error(`Failed to generate tests with Gemini: ${lastError?.message || 'Unknown error'}`);
  }

  private extractGeneratedText(response: any): string {
    try {
      // Gemini response structure
      const candidates = response.candidates || [];
      if (candidates.length === 0) {
        return '';
      }
      
      const content = candidates[0].content;
      if (!content || !content.parts) {
        return '';
      }
      
      // Combine all text parts
      return content.parts
        .map((part: any) => part.text || '')
        .join('')
        .trim();
    } catch (error) {
      console.error('Error extracting Gemini response:', error);
      return '';
    }
  }

  private getModelName(model: string): string {
    // Map user-friendly names to Gemini API model names
    const modelMap: Record<string, string> = {
      'gemini-1.5-pro-latest': 'gemini-1.5-pro-latest',
      'gemini-1.5-flash': 'gemini-1.5-flash',
      'gemini-1.5-flash-8b': 'gemini-1.5-flash-8b',
      'gemini-pro': 'gemini-pro',
      'gemini-pro-vision': 'gemini-pro-vision',
    };
    
    return modelMap[model] || 'gemini-1.5-flash';
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  estimateCost(tokenCount: number, model: string): number {
    // Gemini pricing as of 2024 (approximate)
    const pricing: Record<string, { input: number; output: number }> = {
      'gemini-1.5-pro': { input: 0.00125, output: 0.00375 }, // per 1k tokens
      'gemini-1.5-flash': { input: 0.00015, output: 0.0006 },
      'gemini-pro': { input: 0.0005, output: 0.0015 },
    };
    
    const modelPricing = pricing[model] || pricing['gemini-1.5-flash'];
    // Rough estimate: 60% input, 40% output
    const inputTokens = tokenCount * 0.6;
    const outputTokens = tokenCount * 0.4;
    
    return (inputTokens / 1000) * modelPricing.input + (outputTokens / 1000) * modelPricing.output;
  }

  countTokens(text: string): number {
    try {
      // Use gpt-tokenizer as approximation for Gemini
      const tokens = encode(text);
      return tokens.length;
    } catch (error) {
      // Fallback to rough estimation
      return Math.ceil(text.length / 4);
    }
  }

  private getMaxTokens(model: string): number {
    const limits: Record<string, number> = {
      'gemini-2-5-pro': 2097152,        // Latest Gemini 2.5 Pro - 2M context
      'gemini-2-5-flash': 1048576,      // Latest Gemini 2.5 Flash - 1M context
      'gemini-1.5-pro-latest': 2097152, // Legacy - 2M context window
      'gemini-1.5-flash': 1048576,      // Legacy - 1M context window
      'gemini-1.5-flash-8b': 1048576,   // Legacy - 1M context window
      'gemini-pro': 32768,              // Legacy
    };
    return limits[model] || 32768;
  }

  private buildExhaustivePrompt(harData: HARData, options: GenerationOptions, authFlow?: AuthFlow, customAuthGuide?: string): string {
    const framework = options.framework;
    const entries = harData.entries; // Process ALL entries

    // Group by unique endpoints
    const uniqueEndpoints = new Map<string, any>();
    entries.forEach(entry => {
      try {
        const url = new URL(entry.request.url);
        const signature = `${entry.request.method}:${url.pathname}`;
        if (!uniqueEndpoints.has(signature)) {
          uniqueEndpoints.set(signature, entry);
        }
      } catch {
        const signature = `${entry.request.method}:${entry.request.url}`;
        if (!uniqueEndpoints.has(signature)) {
          uniqueEndpoints.set(signature, entry);
        }
      }
    });

    let prompt = `üö® CRITICAL: Generate COMPLETE ${framework} test code for ALL ${uniqueEndpoints.size} API endpoints.

‚ö†Ô∏è  NO placeholder comments like "// Continue adding more tests..."
‚ö†Ô∏è  GENERATE COMPLETE TEST CODE FOR EVERY SINGLE ENDPOINT
‚ö†Ô∏è  Each endpoint needs 10-15 individual test cases

${this.getFrameworkInstructions(framework)}

üéØ ENDPOINTS TO FULLY TEST (${uniqueEndpoints.size} total):

`;

    Array.from(uniqueEndpoints.values()).forEach((entry, index) => {
      const url = new URL(entry.request.url);
      const method = entry.request.method;
      const statusCode = entry.response.status;
      
      prompt += `
${index + 1}. ${method} ${url.pathname} ‚Üí ${statusCode}
   URL: ${entry.request.url}
   üö® MUST GENERATE: Complete describe() block with 10-15 test() cases
   - Happy path, errors (400,401,403,404,500), edge cases, security tests
`;
    });

    prompt += `

üö® FINAL REQUIREMENTS:
‚úÖ Generate ${uniqueEndpoints.size} complete describe() blocks
‚ùå No "// Continue..." placeholder comments
‚úÖ Production-ready, runnable ${framework} test code
‚úÖ Include setup/teardown hooks

GENERATE COMPLETE TEST CODE NOW:`;

    return prompt;
  }

  private buildPrompt(harData: HARData, options: GenerationOptions): string {
    const framework = options.framework;
    const entries = harData.entries; // Process ALL entries

    let prompt = `Generate comprehensive ${framework} test code for the following API requests.\n\n`;
    
    // Add detailed framework instructions
    prompt += '## Framework Requirements\n';
    prompt += this.getFrameworkInstructions(framework);
    prompt += '\n\n';
    
    // Add test requirements
    prompt += '## Test Requirements\n';
    const requirements = [];
    
    if (options.includeAuth) {
      requirements.push('Authentication tests with proper token/session handling');
    }
    if (options.includeErrorScenarios) {
      requirements.push('Comprehensive error scenarios (4xx and 5xx status codes)');
    }
    if (options.includePerformanceTests) {
      requirements.push('Performance tests with response time assertions');
    }
    if (options.includeSecurityTests) {
      requirements.push('Security tests for common vulnerabilities');
    }
    if (options.generateMockData) {
      requirements.push('Generated mock data instead of production data');
    }
    if (options.includeEdgeCases) {
      requirements.push('Edge case tests (null values, empty arrays, boundary conditions)');
    }
    if (options.includeIntegrationTests) {
      requirements.push('Integration tests covering multiple endpoint interactions');
    }
    
    requirements.forEach(req => {
      prompt += `- ${req}\n`;
    });

    // TODO: Add authentication instructions when parameter scope issue is resolved
    
    prompt += '\n## API Endpoints\n';
    
    // Group and format requests
    const groupedRequests = this.groupRequestsByEndpoint(entries);
    
    for (const [endpoint, requests] of Object.entries(groupedRequests)) {
      prompt += `\n### ${endpoint}\n`;
      requests.forEach((entry, index) => {
        prompt += `${index + 1}. **${entry.request.method}**\n`;
        
        // Add request details
        if (entry.request.headers && entry.request.headers.length > 0) {
          const authHeader = entry.request.headers.find((h: any) => 
            h.name.toLowerCase() === 'authorization'
          );
          if (authHeader) {
            prompt += `   - Auth: ${authHeader.value.substring(0, 20)}...\n`;
          }
        }
        
        if (entry.request.postData?.text) {
          const bodyPreview = entry.request.postData.text.substring(0, 150);
          prompt += `   - Request Body: \`${bodyPreview}...\`\n`;
        }
        
        prompt += `   - Response Status: ${entry.response.status}\n`;
        
        if (entry.response.content?.text) {
          const responsePreview = entry.response.content.text.substring(0, 150);
          prompt += `   - Response Body: \`${responsePreview}...\`\n`;
        }
      });
    }

    prompt += '\n## Code Generation Instructions\n';
    prompt += '1. Generate complete, runnable test code\n';
    prompt += '2. Include all necessary imports and dependencies\n';
    prompt += '3. Use descriptive test names that explain what is being tested\n';
    prompt += '4. Add comprehensive assertions for status codes, response bodies, and headers\n';
    prompt += '5. Include proper error handling and async/await usage\n';
    prompt += '6. Add setup and teardown hooks where appropriate\n';
    prompt += '7. Use environment variables for sensitive data\n';
    prompt += '8. Add comments for complex test logic\n';
    prompt += '9. Ensure tests are independent and can run in any order\n';
    prompt += '10. Follow best practices for the chosen testing framework\n';

    return prompt;
  }

  private groupRequestsByEndpoint(entries: any[]): Record<string, any[]> {
    const grouped: Record<string, any[]> = {};
    
    entries.forEach(entry => {
      try {
        const url = new URL(entry.request.url);
        const endpoint = `${url.pathname}`;
        if (!grouped[endpoint]) {
          grouped[endpoint] = [];
        }
        grouped[endpoint].push(entry);
      } catch (error) {
        // If URL parsing fails, use the full URL
        const endpoint = entry.request.url;
        if (!grouped[endpoint]) {
          grouped[endpoint] = [];
        }
        grouped[endpoint].push(entry);
      }
    });
    
    return grouped;
  }

  private getFrameworkInstructions(framework: string): string {
    const instructions: Record<string, string> = {
      jest: `Jest Testing Framework:
- Use describe() blocks for organizing test suites
- Use it() or test() for individual test cases
- Implement beforeAll()/beforeEach() for setup
- Implement afterAll()/afterEach() for cleanup
- Use expect() with appropriate matchers
- Handle async operations with async/await
- Use jest.mock() for mocking dependencies
- Set appropriate timeouts with jest.setTimeout()`,
      
      playwright: `Playwright Test Framework:
- Use test.describe() for test suites
- Use test() for individual tests
- Use test.beforeAll()/test.beforeEach() for setup
- Use test.afterAll()/test.afterEach() for cleanup
- Use request context for API testing
- Implement proper error handling
- Use expect() with Playwright matchers
- Add test.use() for configuration`,
      
      'mocha-chai': `Mocha with Chai:
- Use describe() for test suites
- Use it() for test cases
- Implement before()/beforeEach() hooks
- Implement after()/afterEach() hooks
- Use chai.expect() or chai.should() for assertions
- Use chai-http for HTTP requests
- Handle async with done callback or promises
- Set timeouts with this.timeout()`,
      
      cypress: `Cypress E2E Testing:
- Use describe() and it() blocks
- Use cy.request() for API testing
- Use cy.intercept() for request interception
- Implement proper assertions with should()
- Use cy.wrap() for promise handling
- Add custom commands in support files
- Use fixtures for test data
- Implement proper retry strategies`,
      
      puppeteer: `Puppeteer with Jest:
- Use describe() and test() blocks
- Initialize browser and page in beforeAll()
- Clean up in afterAll()
- Use page.evaluate() for executing in browser context
- Intercept requests with page.setRequestInterception()
- Take screenshots on failure
- Handle navigation and timeouts properly
- Use page.waitForResponse() for API calls`,
      
      vitest: `Vitest Testing Framework:
- Use describe() and it()/test() blocks
- Use vi.mock() for mocking modules
- Implement beforeAll()/beforeEach() hooks
- Implement afterAll()/afterEach() hooks
- Use expect() with Vitest matchers
- Handle async with async/await
- Use vi.spyOn() for spying on methods
- Add proper TypeScript types`,
      
      supertest: `Supertest API Testing:
- Use describe() and it() blocks
- Initialize app instance for testing
- Use supertest(app) for making requests
- Chain .expect() for assertions
- Use .send() for request bodies
- Use .set() for headers
- Handle async with async/await
- Implement proper error assertions`,
      
      postman: `Postman Collection:
- Create proper collection structure
- Add collection variables
- Implement pre-request scripts
- Write test scripts using pm.test()
- Use pm.expect() for assertions
- Add environment variables
- Include response examples
- Document each request
- Add proper authentication`,
    };

    return instructions[framework] || instructions.jest;
  }

  private calculateQualityScore(code: string, harData: HARData): number {
    let score = 5; // Base score

    // Check endpoint coverage
    const maxEndpoints = Math.min(harData.entries.length, 50);
    const coveredEndpoints = harData.entries.slice(0, maxEndpoints).filter(entry => {
      try {
        const url = new URL(entry.request.url);
        return code.includes(url.pathname) || code.includes(entry.request.url);
      } catch {
        return code.includes(entry.request.url);
      }
    }).length;
    
    score += Math.min(2, (coveredEndpoints / maxEndpoints) * 2);

    // Check for quality indicators
    const qualityIndicators = [
      { pattern: /expect|assert|should/, weight: 0.5 },
      { pattern: /describe|suite|context/, weight: 0.5 },
      { pattern: /async|await|\.then/, weight: 0.5 },
      { pattern: /try|catch|\.catch/, weight: 0.5 },
      { pattern: /before|setup|initialize/, weight: 0.3 },
      { pattern: /after|teardown|cleanup/, weight: 0.3 },
      { pattern: /mock|stub|spy/, weight: 0.4 },
    ];

    qualityIndicators.forEach(({ pattern, weight }) => {
      if (pattern.test(code)) {
        score += weight;
      }
    });

    return Math.min(10, score);
  }

  private analyzeCode(code: string): string[] {
    const warnings: string[] = [];

    // Check for common issues
    const issues = [
      {
        check: () => !(/expect|assert|should/.test(code)),
        message: 'No assertions found in generated tests',
      },
      {
        check: () => /localhost|127\.0\.0\.1/.test(code) && !/process\.env|import\.meta\.env/.test(code),
        message: 'Tests contain hardcoded localhost URLs without environment variables',
      },
      {
        check: () => /Bearer\s+[A-Za-z0-9]/.test(code) && !/process\.env|import\.meta\.env|\$\{/.test(code),
        message: 'API keys or tokens may be hardcoded',
      },
      {
        check: () => code.length < 300,
        message: 'Generated tests seem incomplete or too short',
      },
      {
        check: () => !(/describe|suite|test\.describe/.test(code)),
        message: 'Tests lack proper organization structure',
      },
      {
        check: () => !(/async|await|Promise|\.then/.test(code)),
        message: 'Tests may not handle asynchronous operations properly',
      },
    ];

    issues.forEach(({ check, message }) => {
      if (check()) {
        warnings.push(message);
      }
    });

    return warnings;
  }

  private generateSuggestions(code: string, options: GenerationOptions): string[] {
    const suggestions: string[] = [];

    // Framework-specific suggestions
    const frameworkSuggestions = [
      {
        condition: () => !(/describe|suite/.test(code)) && options.framework !== 'postman',
        message: 'Organize tests in describe blocks for better structure and readability',
      },
      {
        condition: () => !(/timeout|setTimeout/.test(code)),
        message: 'Add timeout configurations for long-running API tests',
      },
      {
        condition: () => !(/before|setup/.test(code)),
        message: 'Add setup hooks for test initialization and data preparation',
      },
      {
        condition: () => !(/after|teardown|cleanup/.test(code)),
        message: 'Add cleanup hooks to prevent test pollution and resource leaks',
      },
      {
        condition: () => options.includePerformanceTests && !(/performance|Date\.now|hrtime/.test(code)),
        message: 'Add explicit performance measurements using performance.now() or process.hrtime()',
      },
      {
        condition: () => !(/mock|stub|spy|nock/.test(code)),
        message: 'Consider mocking external dependencies for more reliable tests',
      },
      {
        condition: () => !(/\.env|process\.env|import\.meta\.env/.test(code)),
        message: 'Use environment variables for configuration and sensitive data',
      },
      {
        condition: () => options.includeErrorScenarios && !(/400|401|403|404|500/.test(code)),
        message: 'Add more comprehensive error scenario tests for different HTTP status codes',
      },
    ];

    frameworkSuggestions.forEach(({ condition, message }) => {
      if (condition()) {
        suggestions.push(message);
      }
    });

    return suggestions;
  }

  private buildStandardizedPromptWrapper(harData: HARData, options: GenerationOptions, authFlow?: AuthFlow, customAuthGuide?: string): string {
    // Inline implementation of standardized prompt to avoid circular dependency
    const framework = options.framework;
    const uniqueEndpoints = this.groupUniqueEndpoints(harData.entries);

    // Build validation section
    const playwrightIndicator = framework === 'playwright' ? ' ‚Üê YOUR SELECTED FRAMEWORK' : '';
    const jestMochaIndicator = ['jest', 'mocha-chai', 'vitest'].includes(framework) ? ' ‚Üê YOUR SELECTED FRAMEWORK' : '';
    const cypressIndicator = framework === 'cypress' ? ' ‚Üê YOUR SELECTED FRAMEWORK' : '';

    const validationSection = `‚ö†Ô∏è FRAMEWORK API VALIDATION - DO NOT MIX:

FOR PLAYWRIGHT${playwrightIndicator}:
‚ùå WRONG: describe() ‚û°Ô∏è ‚úÖ CORRECT: test.describe()
‚ùå WRONG: it() ‚û°Ô∏è ‚úÖ CORRECT: test()
‚ùå WRONG: beforeAll() ‚û°Ô∏è ‚úÖ CORRECT: test.beforeAll()
‚ùå WRONG: expect(response.status).toBe(200) ‚û°Ô∏è ‚úÖ CORRECT: expect(response.status()).toBe(200)

FOR JEST/MOCHA${jestMochaIndicator}:
‚ùå WRONG: test.describe() ‚û°Ô∏è ‚úÖ CORRECT: describe()
‚ùå WRONG: test() in Mocha ‚û°Ô∏è ‚úÖ CORRECT: it()
‚ùå WRONG: test.beforeAll() ‚û°Ô∏è ‚úÖ CORRECT: beforeAll()

FOR CYPRESS${cypressIndicator}:
‚úÖ CORRECT: describe() and it() (globally available)
‚úÖ CORRECT: cy.request() for API calls
‚ùå WRONG: request.get() ‚û°Ô∏è ‚úÖ CORRECT: cy.request()`;

    let prompt = `üî•üî•üî• CRITICAL REQUIREMENT - COMPLETE GENERATION MANDATORY üî•üî•üî•

YOU MUST GENERATE COMPLETE, PRODUCTION-READY ${framework} TEST CODE FOR ALL ${uniqueEndpoints.length} ENDPOINTS.

üö´ ABSOLUTELY FORBIDDEN (INSTANT REJECTION):
‚ùå "Continue adding more tests..." or "Add more tests here"
‚ùå "Follow the same pattern" or "Similar tests can be added"
‚ùå "TODO", "FIXME", or placeholder comments
‚ùå Stopping before all endpoints are complete
‚ùå Template or example code instead of actual implementation
‚ùå MIXING FRAMEWORK APIs (e.g., using describe() in Playwright instead of test.describe())
‚ùå Using wrong assertion methods for the framework
‚ùå Missing framework-specific imports or setup patterns

üéØ MANDATORY SUCCESS CRITERIA:
‚úÖ COMPLETE code for ALL ${uniqueEndpoints.length} endpoints
‚úÖ Each endpoint has its own test group (describe/test.describe) with 10-15 test cases
‚úÖ Production-ready, immediately runnable code with ALL REQUIRED IMPORTS
‚úÖ Comprehensive test coverage: happy path, errors, edge cases, security
‚úÖ Proper authentication handling with token chaining
‚úÖ Framework-specific best practices and correct API usage
‚úÖ Include ALL necessary setup files (package.json, config files)
‚úÖ NO "ReferenceError: describe/test is not defined" or similar runtime errors
‚úÖ STRICTLY follow the chosen framework's API patterns (no mixing frameworks)

‚ö†Ô∏è CRITICAL: MUST INCLUDE COMPLETE SETUP AND CONFIGURATION ‚ö†Ô∏è

Your response MUST include:
1. üìÑ Complete test file with ALL required imports at the top
2. üì¶ package.json with all necessary dependencies and test scripts
3. ‚öôÔ∏è Configuration files (jest.config.js, playwright.config.js, etc.)
4. üìã Setup instructions for running the tests immediately

Framework: ${framework}
${this.getFrameworkInstructions(framework)}

üéØ OUTPUT STRUCTURE REQUIREMENTS:
1. First provide the complete test file with proper imports
2. Then provide package.json with dependencies
3. Then provide configuration files if needed
4. Finally provide setup/run instructions

üìù CODE STYLE REQUIREMENTS:
‚úÖ Use 'const' for all variable declarations (NOT let or var)
‚úÖ Use objects/arrays for data that needs to be modified: const authToken = { value: '' }
‚úÖ Use descriptive variable names: const apiBaseUrl, const userCredentials
‚úÖ Use async/await instead of .then() chains
‚úÖ Include proper error handling with try/catch blocks
‚úÖ Use template literals with backticks for string interpolation

${validationSection}

REQUIRED TEST CATEGORIES FOR EACH ENDPOINT:

1. üü¢ HAPPY PATH TESTS:
   - Valid requests with expected responses
   - Verify response structure and status codes
   - Data validation and business logic checks

2. üî¥ ERROR SCENARIO TESTS:
   - 400: Invalid/malformed requests
   - 401: Missing/invalid authentication
   - 403: Insufficient permissions
   - 404: Resource not found
   - 422: Validation failures
   - 500: Server error handling

3. ‚ö†Ô∏è EDGE CASE TESTS:
   - Empty/null/undefined values
   - Boundary conditions (min/max values)
   - Special characters and Unicode
   - Malformed JSON and invalid data types

4. üîí SECURITY TESTS:
   - Authentication bypass attempts
   - XSS and injection testing
   - Invalid token handling
   - CORS validation

`;

    // Add authentication setup if detected
    if (authFlow) {
      prompt += `\nüîê AUTHENTICATION FLOW DETECTED: ${authFlow.authPattern}\n`;
      if (authFlow.loginEndpoint) {
        prompt += `- Login Endpoint: ${authFlow.loginEndpoint.method} ${authFlow.loginEndpoint.url}\n`;
      }
      prompt += `- Protected Endpoints: ${authFlow.protectedEndpoints.length}\n`;
      prompt += `- CRITICAL: Include proper beforeAll() authentication setup with token extraction and chaining\n`;
    }

    // Add custom authentication guide if provided
    if (customAuthGuide && customAuthGuide.trim()) {
      prompt += `\nüéØ CUSTOM AUTHENTICATION GUIDE:\n${customAuthGuide.trim()}\n`;
      prompt += `CRITICAL: Follow the custom guide above EXACTLY.\n`;
    }

    return prompt;
  }

  // Helper method copied from AIService to avoid circular dependency
  private groupUniqueEndpoints(requests: any[]): any[] {
    const uniqueEndpoints = new Map<string, any>();
    requests.forEach(request => {
      try {
        const url = new URL(request.url);
        const signature = `${request.method}:${url.pathname}`;
        if (!uniqueEndpoints.has(signature)) {
          uniqueEndpoints.set(signature, request);
        }
      } catch (error) {
        const signature = `${request.method}:${request.url}`;
        if (!uniqueEndpoints.has(signature)) {
          uniqueEndpoints.set(signature, request);
        }
      }
    });
    return Array.from(uniqueEndpoints.values());
  }
}